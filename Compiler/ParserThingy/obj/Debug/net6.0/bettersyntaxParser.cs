//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from /home/lasse/repo/git/aau-p4-compiler/Compiler/ParserThingy/bettersyntax.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace ParserThingy {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class bettersyntaxParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, T__14=15, T__15=16, T__16=17, 
		T__17=18, T__18=19, T__19=20, T__20=21, T__21=22, T__22=23, T__23=24, 
		T__24=25, T__25=26, T__26=27, T__27=28, T__28=29, T__29=30, T__30=31, 
		T__31=32, T__32=33, T__33=34, T__34=35, T__35=36, T__36=37, T__37=38, 
		T__38=39, T__39=40, T__40=41, T__41=42, T__42=43, T__43=44, T__44=45, 
		T__45=46, T__46=47, T__47=48, T__48=49, T__49=50, T__50=51, T__51=52, 
		T__52=53, T__53=54, T__54=55, T__55=56, T__56=57, T__57=58, T__58=59, 
		T__59=60, T__60=61, T__61=62, T__62=63, T__63=64, T__64=65, T__65=66, 
		T__66=67, T__67=68, T__68=69;
	public const int
		RULE_program = 0, RULE_function_declaration = 1, RULE_scope = 2, RULE_commands = 3, 
		RULE_letter = 4, RULE_digit = 5, RULE_character = 6, RULE_identifier = 7, 
		RULE_operator = 8;
	public static readonly string[] ruleNames = {
		"program", "function_declaration", "scope", "commands", "letter", "digit", 
		"character", "identifier", "operator"
	};

	private static readonly string[] _LiteralNames = {
		null, "'{'", "'}'", "'A'", "'B'", "'C'", "'D'", "'E'", "'F'", "'G'", "'H'", 
		"'I'", "'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'", "'Q'", "'R'", 
		"'S'", "'T'", "'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'a'", "'b'", 
		"'c'", "'d'", "'e'", "'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", 
		"'m'", "'n'", "'o'", "'p'", "'q'", "'r'", "'s'", "'t'", "'u'", "'v'", 
		"'w'", "'x'", "'y'", "'z'", "'0'", "'1'", "'2'", "'3'", "'4'", "'5'", 
		"'6'", "'7'", "'8'", "'9'", "'_'", "'+'", "'-'", "'*'", "'/'"
	};
	private static readonly string[] _SymbolicNames = {
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "bettersyntax.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public bettersyntaxParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ProgramContext : ParserRuleContext {
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_program);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			 function_declaration scope 
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Function_declarationContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public Function_declarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_function_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterFunction_declaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitFunction_declaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunction_declaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Function_declarationContext function_declaration() {
		Function_declarationContext _localctx = new Function_declarationContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_function_declaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 20; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ScopeContext : ParserRuleContext {
		public ScopeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_scope; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterScope(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitScope(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitScope(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ScopeContext scope() {
		ScopeContext _localctx = new ScopeContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_scope);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 22; Match(T__0);
			 commands 
			State = 24; Match(T__1);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommandsContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CommandsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commands; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterCommands(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitCommands(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommands(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommandsContext commands() {
		CommandsContext _localctx = new CommandsContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_commands);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 26; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetterContext : ParserRuleContext {
		public LetterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letter; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterLetter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitLetter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetterContext letter() {
		LetterContext _localctx = new LetterContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_letter);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 28;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__2) | (1L << T__3) | (1L << T__4) | (1L << T__5) | (1L << T__6) | (1L << T__7) | (1L << T__8) | (1L << T__9) | (1L << T__10) | (1L << T__11) | (1L << T__12) | (1L << T__13) | (1L << T__14) | (1L << T__15) | (1L << T__16) | (1L << T__17) | (1L << T__18) | (1L << T__19) | (1L << T__20) | (1L << T__21) | (1L << T__22) | (1L << T__23) | (1L << T__24) | (1L << T__25) | (1L << T__26) | (1L << T__27) | (1L << T__28) | (1L << T__29) | (1L << T__30) | (1L << T__31) | (1L << T__32) | (1L << T__33) | (1L << T__34) | (1L << T__35) | (1L << T__36) | (1L << T__37) | (1L << T__38) | (1L << T__39) | (1L << T__40) | (1L << T__41) | (1L << T__42) | (1L << T__43) | (1L << T__44) | (1L << T__45) | (1L << T__46) | (1L << T__47) | (1L << T__48) | (1L << T__49) | (1L << T__50) | (1L << T__51) | (1L << T__52) | (1L << T__53))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DigitContext : ParserRuleContext {
		public DigitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_digit; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterDigit(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitDigit(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDigit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DigitContext digit() {
		DigitContext _localctx = new DigitContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_digit);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 30;
			_la = _input.La(1);
			if ( !(((((_la - 55)) & ~0x3f) == 0 && ((1L << (_la - 55)) & ((1L << (T__54 - 55)) | (1L << (T__55 - 55)) | (1L << (T__56 - 55)) | (1L << (T__57 - 55)) | (1L << (T__58 - 55)) | (1L << (T__59 - 55)) | (1L << (T__60 - 55)) | (1L << (T__61 - 55)) | (1L << (T__62 - 55)) | (1L << (T__63 - 55)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CharacterContext : ParserRuleContext {
		public LetterContext letter() {
			return GetRuleContext<LetterContext>(0);
		}
		public DigitContext digit() {
			return GetRuleContext<DigitContext>(0);
		}
		public CharacterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_character; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterCharacter(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitCharacter(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCharacter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CharacterContext character() {
		CharacterContext _localctx = new CharacterContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_character);
		try {
			State = 35;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__2:
			case T__3:
			case T__4:
			case T__5:
			case T__6:
			case T__7:
			case T__8:
			case T__9:
			case T__10:
			case T__11:
			case T__12:
			case T__13:
			case T__14:
			case T__15:
			case T__16:
			case T__17:
			case T__18:
			case T__19:
			case T__20:
			case T__21:
			case T__22:
			case T__23:
			case T__24:
			case T__25:
			case T__26:
			case T__27:
			case T__28:
			case T__29:
			case T__30:
			case T__31:
			case T__32:
			case T__33:
			case T__34:
			case T__35:
			case T__36:
			case T__37:
			case T__38:
			case T__39:
			case T__40:
			case T__41:
			case T__42:
			case T__43:
			case T__44:
			case T__45:
			case T__46:
			case T__47:
			case T__48:
			case T__49:
			case T__50:
			case T__51:
			case T__52:
			case T__53:
				EnterOuterAlt(_localctx, 1);
				{
				State = 32; letter();
				}
				break;
			case T__54:
			case T__55:
			case T__56:
			case T__57:
			case T__58:
			case T__59:
			case T__60:
			case T__61:
			case T__62:
			case T__63:
				EnterOuterAlt(_localctx, 2);
				{
				State = 33; digit();
				}
				break;
			case T__64:
				EnterOuterAlt(_localctx, 3);
				{
				State = 34; Match(T__64);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public LetterContext letter() {
			return GetRuleContext<LetterContext>(0);
		}
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 37; letter();
			 letter | digit | '_' 
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperatorContext : ParserRuleContext {
		public OperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.EnterOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IbettersyntaxListener typedListener = listener as IbettersyntaxListener;
			if (typedListener != null) typedListener.ExitOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IbettersyntaxVisitor<TResult> typedVisitor = visitor as IbettersyntaxVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OperatorContext @operator() {
		OperatorContext _localctx = new OperatorContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_operator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 40;
			_la = _input.La(1);
			if ( !(((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (T__65 - 66)) | (1L << (T__66 - 66)) | (1L << (T__67 - 66)) | (1L << (T__68 - 66)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3G-\x4\x2\t\x2\x4"+
		"\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t\t\x4"+
		"\n\t\n\x3\x2\x3\x2\x3\x3\x3\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3"+
		"\x6\x3\x6\x3\a\x3\a\x3\b\x3\b\x3\b\x5\b&\n\b\x3\t\x3\t\x3\t\x3\n\x3\n"+
		"\x3\n\x2\x2\x2\v\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2"+
		"\x2\x5\x3\x2\x5\x38\x3\x2\x39\x42\x3\x2\x44G%\x2\x14\x3\x2\x2\x2\x4\x16"+
		"\x3\x2\x2\x2\x6\x18\x3\x2\x2\x2\b\x1C\x3\x2\x2\x2\n\x1E\x3\x2\x2\x2\f"+
		" \x3\x2\x2\x2\xE%\x3\x2\x2\x2\x10\'\x3\x2\x2\x2\x12*\x3\x2\x2\x2\x14\x15"+
		"\b\x2\x1\x2\x15\x3\x3\x2\x2\x2\x16\x17\x5\x10\t\x2\x17\x5\x3\x2\x2\x2"+
		"\x18\x19\a\x3\x2\x2\x19\x1A\b\x4\x1\x2\x1A\x1B\a\x4\x2\x2\x1B\a\x3\x2"+
		"\x2\x2\x1C\x1D\x5\x10\t\x2\x1D\t\x3\x2\x2\x2\x1E\x1F\t\x2\x2\x2\x1F\v"+
		"\x3\x2\x2\x2 !\t\x3\x2\x2!\r\x3\x2\x2\x2\"&\x5\n\x6\x2#&\x5\f\a\x2$&\a"+
		"\x43\x2\x2%\"\x3\x2\x2\x2%#\x3\x2\x2\x2%$\x3\x2\x2\x2&\xF\x3\x2\x2\x2"+
		"\'(\x5\n\x6\x2()\b\t\x1\x2)\x11\x3\x2\x2\x2*+\t\x4\x2\x2+\x13\x3\x2\x2"+
		"\x2\x3%";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace ParserThingy
